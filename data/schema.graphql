# The brands of tea
type Brand implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!

  # The unique identifier of the brand
  uuid: Uuid!

  # The name of the brand
  name: String!

  # The url of the website of the brand, if any
  url: String

  # When the brand was added to the database
  createdAt: Datetime!

  # When the brand was last modified in the database
  updatedAt: Datetime!

  # Reads and enables paginatation through a set of `Tea`.
  teasByBrandUuid(
    # The method to use when ordering `Tea`.
    orderBy: TeasOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: TeaCondition
  ): TeasConnection
}

# A condition to be used against `Brand` object types. All fields are tested for equality and combined with a logical ‘and.’
input BrandCondition {
  # Checks for equality with the object’s `uuid` field.
  uuid: Uuid

  # Checks for equality with the object’s `name` field.
  name: String

  # Checks for equality with the object’s `url` field.
  url: String

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime
}

# The brands of tea
input BrandInput {
  # The unique identifier of the brand
  uuid: Uuid

  # The name of the brand
  name: String!

  # The url of the website of the brand, if any
  url: String

  # When the brand was added to the database
  createdAt: Datetime

  # When the brand was last modified in the database
  updatedAt: Datetime
}

# Represents an update to a `Brand`. Fields that are set will be updated.
input BrandPatch {
  # The unique identifier of the brand
  uuid: Uuid

  # The name of the brand
  name: String

  # The url of the website of the brand, if any
  url: String

  # When the brand was added to the database
  createdAt: Datetime

  # When the brand was last modified in the database
  updatedAt: Datetime
}

# A connection to a list of `Brand` values.
type BrandsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Brand` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Brand` and cursor to aid in pagination.
  edges: [BrandsEdge]

  # A list of `Brand` objects.
  nodes: [Brand!]
}

# A `Brand` edge in the connection.
type BrandsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Brand` at the end of the edge.
  node: Brand!
}

# Methods to use when ordering `Brand`.
enum BrandsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  UUID_ASC
  UUID_DESC
  NAME_ASC
  NAME_DESC
  URL_ASC
  URL_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

# A connection to a list of `Category` values.
type CategoriesConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Category` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Category` and cursor to aid in pagination.
  edges: [CategoriesEdge]

  # A list of `Category` objects.
  nodes: [Category!]
}

# A `Category` edge in the connection.
type CategoriesEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Category` at the end of the edge.
  node: Category!
}

# Methods to use when ordering `Category`.
enum CategoriesOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  UUID_ASC
  UUID_DESC
  NAME_ASC
  NAME_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

# The categories of tea
type Category implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!

  # The unique identifier of the category
  uuid: Uuid!

  # The name of the category
  name: String!

  # When the category was added to the database
  createdAt: Datetime!

  # When the category was last modified in the database
  updatedAt: Datetime!

  # Reads and enables paginatation through a set of `Tea`.
  teasByCategoryUuid(
    # The method to use when ordering `Tea`.
    orderBy: TeasOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: TeaCondition
  ): TeasConnection
}

# A condition to be used against `Category` object types. All fields are tested
# for equality and combined with a logical ‘and.’
input CategoryCondition {
  # Checks for equality with the object’s `uuid` field.
  uuid: Uuid

  # Checks for equality with the object’s `name` field.
  name: String

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime
}

# The categories of tea
input CategoryInput {
  # The unique identifier of the category
  uuid: Uuid

  # The name of the category
  name: String!

  # When the category was added to the database
  createdAt: Datetime

  # When the category was last modified in the database
  updatedAt: Datetime
}

# Represents an update to a `Category`. Fields that are set will be updated.
input CategoryPatch {
  # The unique identifier of the category
  uuid: Uuid

  # The name of the category
  name: String

  # When the category was added to the database
  createdAt: Datetime

  # When the category was last modified in the database
  updatedAt: Datetime
}

# All input for the `createBrand` mutation.
input CreateBrandInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `Brand` to be created by this mutation.
  brand: BrandInput!
}

# The output of our `createBrand` mutation.
type CreateBrandPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Brand` that was created by this mutation.
  brand: Brand

  # An edge for our `Brand`. May be used by Relay 1.
  brandEdge(
    # The method to use when ordering `Brand`.
    orderBy: BrandsOrderBy = PRIMARY_KEY_ASC
  ): BrandsEdge

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createCategory` mutation.
input CreateCategoryInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `Category` to be created by this mutation.
  category: CategoryInput!
}

# The output of our `createCategory` mutation.
type CreateCategoryPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Category` that was created by this mutation.
  category: Category

  # An edge for our `Category`. May be used by Relay 1.
  categoryEdge(
    # The method to use when ordering `Category`.
    orderBy: CategoriesOrderBy = PRIMARY_KEY_ASC
  ): CategoriesEdge

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createLabel` mutation.
input CreateLabelInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `Label` to be created by this mutation.
  label: LabelInput!
}

# The output of our `createLabel` mutation.
type CreateLabelPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Label` that was created by this mutation.
  label: Label

  # An edge for our `Label`. May be used by Relay 1.
  labelEdge(
    # The method to use when ordering `Label`.
    orderBy: LabelsOrderBy = PRIMARY_KEY_ASC
  ): LabelsEdge

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createPrice` mutation.
input CreatePriceInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `Price` to be created by this mutation.
  price: PriceInput!
}

# The output of our `createPrice` mutation.
type CreatePricePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Price` that was created by this mutation.
  price: Price

  # An edge for our `Price`. May be used by Relay 1.
  priceEdge(
    # The method to use when ordering `Price`.
    orderBy: PricesOrderBy = PRIMARY_KEY_ASC
  ): PricesEdge

  # Reads a single `Tea` that is related to this `Price`.
  teaByTeaUuid: Tea

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createSteepAdvice` mutation.
input CreateSteepAdviceInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `SteepAdvice` to be created by this mutation.
  steepAdvice: SteepAdviceInput!
}

# The output of our `createSteepAdvice` mutation.
type CreateSteepAdvicePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `SteepAdvice` that was created by this mutation.
  steepAdvice: SteepAdvice

  # An edge for our `SteepAdvice`. May be used by Relay 1.
  steepAdviceEdge(
    # The method to use when ordering `SteepAdvice`.
    orderBy: SteepAdvicesOrderBy = PRIMARY_KEY_ASC
  ): SteepAdvicesEdge

  # Reads a single `Tea` that is related to this `SteepAdvice`.
  teaByTeaUuid: Tea

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createTea` mutation.
input CreateTeaInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `Tea` to be created by this mutation.
  tea: TeaInput!
}

# The output of our `createTea` mutation.
type CreateTeaPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Tea` that was created by this mutation.
  tea: Tea

  # An edge for our `Tea`. May be used by Relay 1.
  teaEdge(
    # The method to use when ordering `Tea`.
    orderBy: TeasOrderBy = PRIMARY_KEY_ASC
  ): TeasEdge

  # Reads a single `Brand` that is related to this `Tea`.
  brandByBrandUuid: Brand

  # Reads a single `Category` that is related to this `Tea`.
  categoryByCategoryUuid: Category

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# A location in a connection that can be used for resuming pagination.
scalar Cursor

# A point in time as described by the [ISO
# 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
scalar Datetime

# All input for the `deleteBrandByName` mutation.
input DeleteBrandByNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The name of the brand
  name: String!
}

# All input for the `deleteBrandByUuid` mutation.
input DeleteBrandByUuidInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The unique identifier of the brand
  uuid: Uuid!
}

# All input for the `deleteBrand` mutation.
input DeleteBrandInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Brand` to be deleted.
  id: ID!
}

# The output of our `deleteBrand` mutation.
type DeleteBrandPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  brand: Brand
  deletedBrandId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteCategoryByName` mutation.
input DeleteCategoryByNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The name of the category
  name: String!
}

# All input for the `deleteCategoryByUuid` mutation.
input DeleteCategoryByUuidInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The unique identifier of the category
  uuid: Uuid!
}

# All input for the `deleteCategory` mutation.
input DeleteCategoryInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Category` to be deleted.
  id: ID!
}

# The output of our `deleteCategory` mutation.
type DeleteCategoryPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  category: Category
  deletedCategoryId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteLabelByName` mutation.
input DeleteLabelByNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The name of the label template
  name: String!
}

# All input for the `deleteLabelByUuid` mutation.
input DeleteLabelByUuidInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The unique identifier of the label template
  uuid: Uuid!
}

# All input for the `deleteLabel` mutation.
input DeleteLabelInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Label` to be deleted.
  id: ID!
}

# The output of our `deleteLabel` mutation.
type DeleteLabelPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  label: Label
  deletedLabelId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deletePriceByAmountAndTeaUuid` mutation.
input DeletePriceByAmountAndTeaUuidInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The amount of tea you get for this price, in grams
  amount: Int!

  # The unique identifier of the tea that this price is for
  teaUuid: Uuid!
}

# All input for the `deletePriceByUuid` mutation.
input DeletePriceByUuidInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The unique identifier of the price
  uuid: Uuid!
}

# All input for the `deletePrice` mutation.
input DeletePriceInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Price` to be deleted.
  id: ID!
}

# The output of our `deletePrice` mutation.
type DeletePricePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  price: Price
  deletedPriceId: ID

  # Reads a single `Tea` that is related to this `Price`.
  teaByTeaUuid: Tea

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteSteepAdviceByNameAndTeaUuid` mutation.
input DeleteSteepAdviceByNameAndTeaUuidInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The name of the steep advice
  name: String!

  # The unique identifier of the tea that this steep advice is for
  teaUuid: Uuid!
}

# All input for the `deleteSteepAdviceByUuid` mutation.
input DeleteSteepAdviceByUuidInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The unique identifier of the steep advice
  uuid: Uuid!
}

# All input for the `deleteSteepAdvice` mutation.
input DeleteSteepAdviceInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `SteepAdvice` to be deleted.
  id: ID!
}

# The output of our `deleteSteepAdvice` mutation.
type DeleteSteepAdvicePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  steepAdvice: SteepAdvice
  deletedSteepAdviceId: ID

  # Reads a single `Tea` that is related to this `SteepAdvice`.
  teaByTeaUuid: Tea

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteTeaByNameAndBrandUuid` mutation.
input DeleteTeaByNameAndBrandUuidInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The name of the tea
  name: String!

  # The unique identifier of the brand of the tea
  brandUuid: Uuid!
}

# All input for the `deleteTeaByUuid` mutation.
input DeleteTeaByUuidInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The unique identifier of the tea
  uuid: Uuid!
}

# All input for the `deleteTea` mutation.
input DeleteTeaInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Tea` to be deleted.
  id: ID!
}

# The output of our `deleteTea` mutation.
type DeleteTeaPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  tea: Tea
  deletedTeaId: ID

  # Reads a single `Brand` that is related to this `Tea`.
  brandByBrandUuid: Brand

  # Reads a single `Category` that is related to this `Tea`.
  categoryByCategoryUuid: Category

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# range of numerics
type FloatRange {
  # The starting bound of our range.
  start: FloatRangeBound

  # The ending bound of our range.
  end: FloatRangeBound
}

# The value at one end of a range. A range can either include this value, or not.
type FloatRangeBound {
  # The value at one end of our range.
  value: Float!

  # Whether or not the value of this bound is included in the range.
  inclusive: Boolean!
}

# The value at one end of a range. A range can either include this value, or not.
input FloatRangeBoundInput {
  # The value at one end of our range.
  value: Float!

  # Whether or not the value of this bound is included in the range.
  inclusive: Boolean!
}

# range of numerics
input FloatRangeInput {
  # The starting bound of our range.
  start: FloatRangeBoundInput

  # The ending bound of our range.
  end: FloatRangeBoundInput
}

# All input for the `genRandomBytes` mutation.
input GenRandomBytesInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  arg0: Int!
}

# The output of our `genRandomBytes` mutation.
type GenRandomBytesPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  string: String

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `genRandomUuid` mutation.
input GenRandomUuidInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
}

# The output of our `genRandomUuid` mutation.
type GenRandomUuidPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  uuid: Uuid

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# A connection to a list of `Brand` values.
type GetBrandsForAutocompleteConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Brand` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Brand` and cursor to aid in pagination.
  edges: [GetBrandsForAutocompleteEdge]

  # A list of `Brand` objects.
  nodes: [Brand]
}

# A `Brand` edge in the connection.
type GetBrandsForAutocompleteEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Brand` at the end of the edge.
  node: Brand
}

# Methods to use when ordering `Brand`.
enum GetBrandsForAutocompleteOrderBy {
  NATURAL
}

# A connection to a list of `Category` values.
type GetCategoriesForAutocompleteConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Category` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Category` and cursor to aid in pagination.
  edges: [GetCategoriesForAutocompleteEdge]

  # A list of `Category` objects.
  nodes: [Category]
}

# A `Category` edge in the connection.
type GetCategoriesForAutocompleteEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Category` at the end of the edge.
  node: Category
}

# Methods to use when ordering `Category`.
enum GetCategoriesForAutocompleteOrderBy {
  NATURAL
}

# range of integers
type IntegerRange {
  # The starting bound of our range.
  start: IntegerRangeBound

  # The ending bound of our range.
  end: IntegerRangeBound
}

# The value at one end of a range. A range can either include this value, or not.
type IntegerRangeBound {
  # The value at one end of our range.
  value: Int!

  # Whether or not the value of this bound is included in the range.
  inclusive: Boolean!
}

# The value at one end of a range. A range can either include this value, or not.
input IntegerRangeBoundInput {
  # The value at one end of our range.
  value: Int!

  # Whether or not the value of this bound is included in the range.
  inclusive: Boolean!
}

# range of integers
input IntegerRangeInput {
  # The starting bound of our range.
  start: IntegerRangeBoundInput

  # The ending bound of our range.
  end: IntegerRangeBoundInput
}

# The label templates
type Label implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!

  # The unique identifier of the label template
  uuid: Uuid!

  # The name of the label template
  name: String!

  # The XML template
  xml: String!

  # When the label template was added to the database
  createdAt: Datetime!

  # When the label template was last modified in the database
  updatedAt: Datetime!
}

# A condition to be used against `Label` object types. All fields are tested for equality and combined with a logical ‘and.’
input LabelCondition {
  # Checks for equality with the object’s `uuid` field.
  uuid: Uuid

  # Checks for equality with the object’s `name` field.
  name: String

  # Checks for equality with the object’s `xml` field.
  xml: String

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime
}

# The label templates
input LabelInput {
  # The unique identifier of the label template
  uuid: Uuid

  # The name of the label template
  name: String!

  # The XML template
  xml: String!

  # When the label template was added to the database
  createdAt: Datetime

  # When the label template was last modified in the database
  updatedAt: Datetime
}

# Represents an update to a `Label`. Fields that are set will be updated.
input LabelPatch {
  # The unique identifier of the label template
  uuid: Uuid

  # The name of the label template
  name: String

  # The XML template
  xml: String

  # When the label template was added to the database
  createdAt: Datetime

  # When the label template was last modified in the database
  updatedAt: Datetime
}

# A connection to a list of `Label` values.
type LabelsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Label` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Label` and cursor to aid in pagination.
  edges: [LabelsEdge]

  # A list of `Label` objects.
  nodes: [Label!]
}

# A `Label` edge in the connection.
type LabelsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Label` at the end of the edge.
  node: Label!
}

# Methods to use when ordering `Label`.
enum LabelsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  UUID_ASC
  UUID_DESC
  NAME_ASC
  NAME_DESC
  XML_ASC
  XML_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

# The root mutation type which contains root level fields which mutate data.
type Mutation {
  genRandomBytes(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: GenRandomBytesInput!
  ): GenRandomBytesPayload
  genRandomUuid(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: GenRandomUuidInput!
  ): GenRandomUuidPayload
  setLimit(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: SetLimitInput!
  ): SetLimitPayload
  updateUpdatedAt(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateUpdatedAtInput!
  ): UpdateUpdatedAtPayload

  # Creates a single `Brand`.
  createBrand(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateBrandInput!
  ): CreateBrandPayload

  # Updates a single `Brand` using its globally unique id and a patch.
  updateBrand(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateBrandInput!
  ): UpdateBrandPayload

  # Updates a single `Brand` using a unique key and a patch.
  updateBrandByUuid(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateBrandByUuidInput!
  ): UpdateBrandPayload

  # Updates a single `Brand` using a unique key and a patch.
  updateBrandByName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateBrandByNameInput!
  ): UpdateBrandPayload

  # Deletes a single `Brand` using its globally unique id.
  deleteBrand(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteBrandInput!
  ): DeleteBrandPayload

  # Deletes a single `Brand` using a unique key.
  deleteBrandByUuid(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteBrandByUuidInput!
  ): DeleteBrandPayload

  # Deletes a single `Brand` using a unique key.
  deleteBrandByName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteBrandByNameInput!
  ): DeleteBrandPayload

  # Creates a single `Category`.
  createCategory(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateCategoryInput!
  ): CreateCategoryPayload

  # Updates a single `Category` using its globally unique id and a patch.
  updateCategory(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateCategoryInput!
  ): UpdateCategoryPayload

  # Updates a single `Category` using a unique key and a patch.
  updateCategoryByUuid(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateCategoryByUuidInput!
  ): UpdateCategoryPayload

  # Updates a single `Category` using a unique key and a patch.
  updateCategoryByName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateCategoryByNameInput!
  ): UpdateCategoryPayload

  # Deletes a single `Category` using its globally unique id.
  deleteCategory(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteCategoryInput!
  ): DeleteCategoryPayload

  # Deletes a single `Category` using a unique key.
  deleteCategoryByUuid(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteCategoryByUuidInput!
  ): DeleteCategoryPayload

  # Deletes a single `Category` using a unique key.
  deleteCategoryByName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteCategoryByNameInput!
  ): DeleteCategoryPayload

  # Creates a single `Label`.
  createLabel(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateLabelInput!
  ): CreateLabelPayload

  # Updates a single `Label` using its globally unique id and a patch.
  updateLabel(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateLabelInput!
  ): UpdateLabelPayload

  # Updates a single `Label` using a unique key and a patch.
  updateLabelByUuid(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateLabelByUuidInput!
  ): UpdateLabelPayload

  # Updates a single `Label` using a unique key and a patch.
  updateLabelByName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateLabelByNameInput!
  ): UpdateLabelPayload

  # Deletes a single `Label` using its globally unique id.
  deleteLabel(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteLabelInput!
  ): DeleteLabelPayload

  # Deletes a single `Label` using a unique key.
  deleteLabelByUuid(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteLabelByUuidInput!
  ): DeleteLabelPayload

  # Deletes a single `Label` using a unique key.
  deleteLabelByName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteLabelByNameInput!
  ): DeleteLabelPayload

  # Creates a single `Price`.
  createPrice(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreatePriceInput!
  ): CreatePricePayload

  # Updates a single `Price` using its globally unique id and a patch.
  updatePrice(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdatePriceInput!
  ): UpdatePricePayload

  # Updates a single `Price` using a unique key and a patch.
  updatePriceByUuid(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdatePriceByUuidInput!
  ): UpdatePricePayload

  # Updates a single `Price` using a unique key and a patch.
  updatePriceByAmountAndTeaUuid(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdatePriceByAmountAndTeaUuidInput!
  ): UpdatePricePayload

  # Deletes a single `Price` using its globally unique id.
  deletePrice(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeletePriceInput!
  ): DeletePricePayload

  # Deletes a single `Price` using a unique key.
  deletePriceByUuid(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeletePriceByUuidInput!
  ): DeletePricePayload

  # Deletes a single `Price` using a unique key.
  deletePriceByAmountAndTeaUuid(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeletePriceByAmountAndTeaUuidInput!
  ): DeletePricePayload

  # Creates a single `SteepAdvice`.
  createSteepAdvice(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateSteepAdviceInput!
  ): CreateSteepAdvicePayload

  # Updates a single `SteepAdvice` using its globally unique id and a patch.
  updateSteepAdvice(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateSteepAdviceInput!
  ): UpdateSteepAdvicePayload

  # Updates a single `SteepAdvice` using a unique key and a patch.
  updateSteepAdviceByUuid(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateSteepAdviceByUuidInput!
  ): UpdateSteepAdvicePayload

  # Updates a single `SteepAdvice` using a unique key and a patch.
  updateSteepAdviceByNameAndTeaUuid(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateSteepAdviceByNameAndTeaUuidInput!
  ): UpdateSteepAdvicePayload

  # Deletes a single `SteepAdvice` using its globally unique id.
  deleteSteepAdvice(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteSteepAdviceInput!
  ): DeleteSteepAdvicePayload

  # Deletes a single `SteepAdvice` using a unique key.
  deleteSteepAdviceByUuid(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteSteepAdviceByUuidInput!
  ): DeleteSteepAdvicePayload

  # Deletes a single `SteepAdvice` using a unique key.
  deleteSteepAdviceByNameAndTeaUuid(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteSteepAdviceByNameAndTeaUuidInput!
  ): DeleteSteepAdvicePayload

  # Creates a single `Tea`.
  createTea(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateTeaInput!
  ): CreateTeaPayload

  # Updates a single `Tea` using its globally unique id and a patch.
  updateTea(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateTeaInput!
  ): UpdateTeaPayload

  # Updates a single `Tea` using a unique key and a patch.
  updateTeaByUuid(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateTeaByUuidInput!
  ): UpdateTeaPayload

  # Updates a single `Tea` using a unique key and a patch.
  updateTeaByNameAndBrandUuid(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateTeaByNameAndBrandUuidInput!
  ): UpdateTeaPayload

  # Deletes a single `Tea` using its globally unique id.
  deleteTea(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteTeaInput!
  ): DeleteTeaPayload

  # Deletes a single `Tea` using a unique key.
  deleteTeaByUuid(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteTeaByUuidInput!
  ): DeleteTeaPayload

  # Deletes a single `Tea` using a unique key.
  deleteTeaByNameAndBrandUuid(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteTeaByNameAndBrandUuidInput!
  ): DeleteTeaPayload
}

# An object with a globally unique `ID`.
interface Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!
}

# Information about pagination in a connection.
type PageInfo {
  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: Cursor

  # When paginating forwards, the cursor to continue.
  endCursor: Cursor
}

# The prices of the teas
type Price implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!

  # The unique identifier of the price
  uuid: Uuid!

  # The price, in euro
  price: Float!

  # The amount of tea you get for this price, in grams
  amount: Int!

  # The unique identifier of the tea that this price is for
  teaUuid: Uuid!

  # When the price was added to the database
  createdAt: Datetime!

  # When the price was last modified in the database
  updatedAt: Datetime!

  # Reads a single `Tea` that is related to this `Price`.
  teaByTeaUuid: Tea
}

# A condition to be used against `Price` object types. All fields are tested for equality and combined with a logical ‘and.’
input PriceCondition {
  # Checks for equality with the object’s `uuid` field.
  uuid: Uuid

  # Checks for equality with the object’s `price` field.
  price: Float

  # Checks for equality with the object’s `amount` field.
  amount: Int

  # Checks for equality with the object’s `teaUuid` field.
  teaUuid: Uuid

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime
}

# The prices of the teas
input PriceInput {
  # The unique identifier of the price
  uuid: Uuid

  # The price, in euro
  price: Float!

  # The amount of tea you get for this price, in grams
  amount: Int!

  # The unique identifier of the tea that this price is for
  teaUuid: Uuid!

  # When the price was added to the database
  createdAt: Datetime

  # When the price was last modified in the database
  updatedAt: Datetime
}

# Represents an update to a `Price`. Fields that are set will be updated.
input PricePatch {
  # The unique identifier of the price
  uuid: Uuid

  # The price, in euro
  price: Float

  # The amount of tea you get for this price, in grams
  amount: Int

  # The unique identifier of the tea that this price is for
  teaUuid: Uuid

  # When the price was added to the database
  createdAt: Datetime

  # When the price was last modified in the database
  updatedAt: Datetime
}

# A connection to a list of `Price` values.
type PricesConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Price` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Price` and cursor to aid in pagination.
  edges: [PricesEdge]

  # A list of `Price` objects.
  nodes: [Price!]
}

# A `Price` edge in the connection.
type PricesEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Price` at the end of the edge.
  node: Price!
}

# Methods to use when ordering `Price`.
enum PricesOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  UUID_ASC
  UUID_DESC
  PRICE_ASC
  PRICE_DESC
  AMOUNT_ASC
  AMOUNT_DESC
  TEA_UUID_ASC
  TEA_UUID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

# The root query type which gives access points into the data universe.
type Query implements Node {
  # Fetches an object given its globally unique `ID`.
  node(
    # The globally unique `ID`.
    id: ID!
  ): Node
  crypt(arg0: String!, arg1: String!): String
  dearmor(arg0: String!): String
  decrypt(arg0: String!, arg1: String!, arg2: String!): String
  decryptIv(arg0: String!, arg1: String!, arg2: String!, arg3: String!): String
  encrypt(arg0: String!, arg1: String!, arg2: String!): String
  encryptIv(arg0: String!, arg1: String!, arg2: String!, arg3: String!): String

  # Get the brands for the autocompletion, based on the search term.This doesn't
  # filter out values, but rather orders them from most to least likely.
  getBrandsForAutocomplete(
    # The method to use when ordering `Brand`.
    orderBy: GetBrandsForAutocompleteOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int
    search: String
  ): GetBrandsForAutocompleteConnection

  # Get the categories for the autocompletion, based on the search term. This
  # doesn't filter out values, but rather orders them from most to least likely.
  getCategoriesForAutocomplete(
    # The method to use when ordering `Category`.
    orderBy: GetCategoriesForAutocompleteOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int
    search: String
  ): GetCategoriesForAutocompleteConnection
  ginExtractQueryTrgm(arg0: String!, arg1: String!, arg2: Int!, arg3: String!, arg4: String!, arg5: String!, arg6: String!): String
  ginExtractValueTrgm(arg0: String!, arg1: String!): String
  ginTrgmConsistent(arg0: String!, arg1: Int!, arg2: String!, arg3: Int!, arg4: String!, arg5: String!, arg6: String!, arg7: String!): Boolean
  ginTrgmTriconsistent(arg0: String!, arg1: Int!, arg2: String!, arg3: Int!, arg4: String!, arg5: String!, arg6: String!): String
  gtrgmCompress(arg0: String!): String
  gtrgmConsistent(arg0: String!, arg1: String!, arg2: Int!, arg3: Float!, arg4: String!): Boolean
  gtrgmDecompress(arg0: String!): String
  gtrgmDistance(arg0: String!, arg1: String!, arg2: Int!, arg3: Float!, arg4: String!): Float
  gtrgmIn(arg0: String!): String
  gtrgmOut(arg0: String!): String
  gtrgmPenalty(arg0: String!, arg1: String!, arg2: String!): String
  gtrgmPicksplit(arg0: String!, arg1: String!): String
  gtrgmSame(arg0: String!, arg1: String!, arg2: String!): String
  gtrgmUnion(arg0: String!, arg1: String!): String
  pgpKeyId(arg0: String!): String
  showLimit: Float
  showTrgm(arg0: String!): [String]
  similarity(arg0: String!, arg1: String!): Float
  similarityDist(arg0: String!, arg1: String!): Float
  similarityOp(arg0: String!, arg1: String!): Boolean
  wordSimilarity(arg0: String!, arg1: String!): Float
  wordSimilarityCommutatorOp(arg0: String!, arg1: String!): Boolean
  wordSimilarityDistCommutatorOp(arg0: String!, arg1: String!): Float
  wordSimilarityDistOp(arg0: String!, arg1: String!): Float
  wordSimilarityOp(arg0: String!, arg1: String!): Boolean

  # Reads and enables paginatation through a set of `Brand`.
  allBrands(
    # The method to use when ordering `Brand`.
    orderBy: BrandsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: BrandCondition
  ): BrandsConnection

  # Reads a single `Brand` using its globally unique `ID`.
  brand(
    # The globally unique `ID` to be used in selecting a single `Brand`.
    id: ID!
  ): Brand
  brandByUuid(
    # The unique identifier of the brand
    uuid: Uuid!
  ): Brand
  brandByName(
    # The name of the brand
    name: String!
  ): Brand

  # Reads and enables paginatation through a set of `Category`.
  allCategories(
    # The method to use when ordering `Category`.
    orderBy: CategoriesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: CategoryCondition
  ): CategoriesConnection

  # Reads a single `Category` using its globally unique `ID`.
  category(
    # The globally unique `ID` to be used in selecting a single `Category`.
    id: ID!
  ): Category
  categoryByUuid(
    # The unique identifier of the category
    uuid: Uuid!
  ): Category
  categoryByName(
    # The name of the category
    name: String!
  ): Category

  # Reads and enables paginatation through a set of `Label`.
  allLabels(
    # The method to use when ordering `Label`.
    orderBy: LabelsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: LabelCondition
  ): LabelsConnection

  # Reads a single `Label` using its globally unique `ID`.
  label(
    # The globally unique `ID` to be used in selecting a single `Label`.
    id: ID!
  ): Label
  labelByUuid(
    # The unique identifier of the label template
    uuid: Uuid!
  ): Label
  labelByName(
    # The name of the label template
    name: String!
  ): Label

  # Reads and enables paginatation through a set of `Price`.
  allPrices(
    # The method to use when ordering `Price`.
    orderBy: PricesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: PriceCondition
  ): PricesConnection

  # Reads a single `Price` using its globally unique `ID`.
  price(
    # The globally unique `ID` to be used in selecting a single `Price`.
    id: ID!
  ): Price
  priceByUuid(
    # The unique identifier of the price
    uuid: Uuid!
  ): Price
  priceByAmountAndTeaUuid(
    # The amount of tea you get for this price, in grams
    amount: Int!

    # The unique identifier of the tea that this price is for
    teaUuid: Uuid!
  ): Price

  # Reads and enables paginatation through a set of `SteepAdvice`.
  allSteepAdvices(
    # The method to use when ordering `SteepAdvice`.
    orderBy: SteepAdvicesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: SteepAdviceCondition
  ): SteepAdvicesConnection

  # Reads a single `SteepAdvice` using its globally unique `ID`.
  steepAdvice(
    # The globally unique `ID` to be used in selecting a single `SteepAdvice`.
    id: ID!
  ): SteepAdvice
  steepAdviceByUuid(
    # The unique identifier of the steep advice
    uuid: Uuid!
  ): SteepAdvice
  steepAdviceByNameAndTeaUuid(
    # The name of the steep advice
    name: String!

    # The unique identifier of the tea that this steep advice is for
    teaUuid: Uuid!
  ): SteepAdvice

  # Reads and enables paginatation through a set of `Tea`.
  allTeas(
    # The method to use when ordering `Tea`.
    orderBy: TeasOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: TeaCondition
  ): TeasConnection

  # Reads a single `Tea` using its globally unique `ID`.
  tea(
    # The globally unique `ID` to be used in selecting a single `Tea`.
    id: ID!
  ): Tea
  teaByUuid(
    # The unique identifier of the tea
    uuid: Uuid!
  ): Tea
  teaByNameAndBrandUuid(
    # The name of the tea
    name: String!

    # The unique identifier of the brand of the tea
    brandUuid: Uuid!
  ): Tea

  # Exposes the root query type nested one level down. This is helpful for Relay 1
  # which can only query top level fields if they are in a particular form.
  query: Query!

  # The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.
  id: ID!
}

# All input for the `setLimit` mutation.
input SetLimitInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  arg0: Float!
}

# The output of our `setLimit` mutation.
type SetLimitPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  float: Float

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# The steep advices of the teas
type SteepAdvice implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!

  # The unique identifier of the steep advice
  uuid: Uuid!

  # The name of the steep advice
  name: String!

  # The detailed description of the steep advice, if applicable
  description: String

  # The advised amount of tea, in grams
  amount: FloatRange!

  # The advised steeping duration, in seconds
  duration: IntegerRange!

  # The advised temperature, in celcius
  temperature: IntegerRange!

  # The unique identifier of the tea that this steep advice is for
  teaUuid: Uuid!

  # When the steep advice was added to the database
  createdAt: Datetime!

  # When the steep advice was last modified in the database
  updatedAt: Datetime!

  # Reads a single `Tea` that is related to this `SteepAdvice`.
  teaByTeaUuid: Tea
}

# A condition to be used against `SteepAdvice` object types. All fields are tested
# for equality and combined with a logical ‘and.’
input SteepAdviceCondition {
  # Checks for equality with the object’s `uuid` field.
  uuid: Uuid

  # Checks for equality with the object’s `name` field.
  name: String

  # Checks for equality with the object’s `description` field.
  description: String

  # Checks for equality with the object’s `amount` field.
  amount: FloatRangeInput

  # Checks for equality with the object’s `duration` field.
  duration: IntegerRangeInput

  # Checks for equality with the object’s `temperature` field.
  temperature: IntegerRangeInput

  # Checks for equality with the object’s `teaUuid` field.
  teaUuid: Uuid

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime
}

# The steep advices of the teas
input SteepAdviceInput {
  # The unique identifier of the steep advice
  uuid: Uuid

  # The name of the steep advice
  name: String!

  # The detailed description of the steep advice, if applicable
  description: String

  # The advised amount of tea, in grams
  amount: FloatRangeInput!

  # The advised steeping duration, in seconds
  duration: IntegerRangeInput!

  # The advised temperature, in celcius
  temperature: IntegerRangeInput!

  # The unique identifier of the tea that this steep advice is for
  teaUuid: Uuid!

  # When the steep advice was added to the database
  createdAt: Datetime

  # When the steep advice was last modified in the database
  updatedAt: Datetime
}

# Represents an update to a `SteepAdvice`. Fields that are set will be updated.
input SteepAdvicePatch {
  # The unique identifier of the steep advice
  uuid: Uuid

  # The name of the steep advice
  name: String

  # The detailed description of the steep advice, if applicable
  description: String

  # The advised amount of tea, in grams
  amount: FloatRangeInput

  # The advised steeping duration, in seconds
  duration: IntegerRangeInput

  # The advised temperature, in celcius
  temperature: IntegerRangeInput

  # The unique identifier of the tea that this steep advice is for
  teaUuid: Uuid

  # When the steep advice was added to the database
  createdAt: Datetime

  # When the steep advice was last modified in the database
  updatedAt: Datetime
}

# A connection to a list of `SteepAdvice` values.
type SteepAdvicesConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `SteepAdvice` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `SteepAdvice` and cursor to aid in pagination.
  edges: [SteepAdvicesEdge]

  # A list of `SteepAdvice` objects.
  nodes: [SteepAdvice!]
}

# A `SteepAdvice` edge in the connection.
type SteepAdvicesEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `SteepAdvice` at the end of the edge.
  node: SteepAdvice!
}

# Methods to use when ordering `SteepAdvice`.
enum SteepAdvicesOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  UUID_ASC
  UUID_DESC
  NAME_ASC
  NAME_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  AMOUNT_ASC
  AMOUNT_DESC
  DURATION_ASC
  DURATION_DESC
  TEMPERATURE_ASC
  TEMPERATURE_DESC
  TEA_UUID_ASC
  TEA_UUID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

# The teas
type Tea implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!

  # The unique identifier of the tea
  uuid: Uuid!

  # The name of the tea
  name: String!

  # The unique identifier of the brand of the tea
  brandUuid: Uuid!

  # The unique identifier of the category of the tea
  categoryUuid: Uuid!

  # When the tea was added to the database
  createdAt: Datetime!

  # When the tea was last modified in the database
  updatedAt: Datetime!

  # Reads a single `Brand` that is related to this `Tea`.
  brandByBrandUuid: Brand

  # Reads a single `Category` that is related to this `Tea`.
  categoryByCategoryUuid: Category

  # Reads and enables paginatation through a set of `Price`.
  pricesByTeaUuid(
    # The method to use when ordering `Price`.
    orderBy: PricesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: PriceCondition
  ): PricesConnection

  # Reads and enables paginatation through a set of `SteepAdvice`.
  steepAdvicesByTeaUuid(
    # The method to use when ordering `SteepAdvice`.
    orderBy: SteepAdvicesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: SteepAdviceCondition
  ): SteepAdvicesConnection
}

# A condition to be used against `Tea` object types. All fields are tested for equality and combined with a logical ‘and.’
input TeaCondition {
  # Checks for equality with the object’s `uuid` field.
  uuid: Uuid

  # Checks for equality with the object’s `name` field.
  name: String

  # Checks for equality with the object’s `brandUuid` field.
  brandUuid: Uuid

  # Checks for equality with the object’s `categoryUuid` field.
  categoryUuid: Uuid

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime
}

# The teas
input TeaInput {
  # The unique identifier of the tea
  uuid: Uuid

  # The name of the tea
  name: String!

  # The unique identifier of the brand of the tea
  brandUuid: Uuid!

  # The unique identifier of the category of the tea
  categoryUuid: Uuid!

  # When the tea was added to the database
  createdAt: Datetime

  # When the tea was last modified in the database
  updatedAt: Datetime
}

# Represents an update to a `Tea`. Fields that are set will be updated.
input TeaPatch {
  # The unique identifier of the tea
  uuid: Uuid

  # The name of the tea
  name: String

  # The unique identifier of the brand of the tea
  brandUuid: Uuid

  # The unique identifier of the category of the tea
  categoryUuid: Uuid

  # When the tea was added to the database
  createdAt: Datetime

  # When the tea was last modified in the database
  updatedAt: Datetime
}

# A connection to a list of `Tea` values.
type TeasConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Tea` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Tea` and cursor to aid in pagination.
  edges: [TeasEdge]

  # A list of `Tea` objects.
  nodes: [Tea!]
}

# A `Tea` edge in the connection.
type TeasEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Tea` at the end of the edge.
  node: Tea!
}

# Methods to use when ordering `Tea`.
enum TeasOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  UUID_ASC
  UUID_DESC
  NAME_ASC
  NAME_DESC
  BRAND_UUID_ASC
  BRAND_UUID_DESC
  CATEGORY_UUID_ASC
  CATEGORY_UUID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

# All input for the `updateBrandByName` mutation.
input UpdateBrandByNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The name of the brand
  name: String!

  # An object where the defined keys will be set on the `Brand` identified by our unique key.
  brandPatch: BrandPatch!
}

# All input for the `updateBrandByUuid` mutation.
input UpdateBrandByUuidInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The unique identifier of the brand
  uuid: Uuid!

  # An object where the defined keys will be set on the `Brand` identified by our unique key.
  brandPatch: BrandPatch!
}

# All input for the `updateBrand` mutation.
input UpdateBrandInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Brand` to be updated.
  id: ID!

  # An object where the defined keys will be set on the `Brand` identified by our globally unique `ID`.
  brandPatch: BrandPatch!
}

# The output of our `updateBrand` mutation.
type UpdateBrandPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  brand: Brand

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateCategoryByName` mutation.
input UpdateCategoryByNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The name of the category
  name: String!

  # An object where the defined keys will be set on the `Category` identified by our unique key.
  categoryPatch: CategoryPatch!
}

# All input for the `updateCategoryByUuid` mutation.
input UpdateCategoryByUuidInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The unique identifier of the category
  uuid: Uuid!

  # An object where the defined keys will be set on the `Category` identified by our unique key.
  categoryPatch: CategoryPatch!
}

# All input for the `updateCategory` mutation.
input UpdateCategoryInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Category` to be updated.
  id: ID!

  # An object where the defined keys will be set on the `Category` identified by our globally unique `ID`.
  categoryPatch: CategoryPatch!
}

# The output of our `updateCategory` mutation.
type UpdateCategoryPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  category: Category

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateLabelByName` mutation.
input UpdateLabelByNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The name of the label template
  name: String!

  # An object where the defined keys will be set on the `Label` identified by our unique key.
  labelPatch: LabelPatch!
}

# All input for the `updateLabelByUuid` mutation.
input UpdateLabelByUuidInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The unique identifier of the label template
  uuid: Uuid!

  # An object where the defined keys will be set on the `Label` identified by our unique key.
  labelPatch: LabelPatch!
}

# All input for the `updateLabel` mutation.
input UpdateLabelInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Label` to be updated.
  id: ID!

  # An object where the defined keys will be set on the `Label` identified by our globally unique `ID`.
  labelPatch: LabelPatch!
}

# The output of our `updateLabel` mutation.
type UpdateLabelPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  label: Label

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updatePriceByAmountAndTeaUuid` mutation.
input UpdatePriceByAmountAndTeaUuidInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The amount of tea you get for this price, in grams
  amount: Int!

  # The unique identifier of the tea that this price is for
  teaUuid: Uuid!

  # An object where the defined keys will be set on the `Price` identified by our unique key.
  pricePatch: PricePatch!
}

# All input for the `updatePriceByUuid` mutation.
input UpdatePriceByUuidInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The unique identifier of the price
  uuid: Uuid!

  # An object where the defined keys will be set on the `Price` identified by our unique key.
  pricePatch: PricePatch!
}

# All input for the `updatePrice` mutation.
input UpdatePriceInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Price` to be updated.
  id: ID!

  # An object where the defined keys will be set on the `Price` identified by our globally unique `ID`.
  pricePatch: PricePatch!
}

# The output of our `updatePrice` mutation.
type UpdatePricePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  price: Price

  # Reads a single `Tea` that is related to this `Price`.
  teaByTeaUuid: Tea

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateSteepAdviceByNameAndTeaUuid` mutation.
input UpdateSteepAdviceByNameAndTeaUuidInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The name of the steep advice
  name: String!

  # The unique identifier of the tea that this steep advice is for
  teaUuid: Uuid!

  # An object where the defined keys will be set on the `SteepAdvice` identified by our unique key.
  steepAdvicePatch: SteepAdvicePatch!
}

# All input for the `updateSteepAdviceByUuid` mutation.
input UpdateSteepAdviceByUuidInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The unique identifier of the steep advice
  uuid: Uuid!

  # An object where the defined keys will be set on the `SteepAdvice` identified by our unique key.
  steepAdvicePatch: SteepAdvicePatch!
}

# All input for the `updateSteepAdvice` mutation.
input UpdateSteepAdviceInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `SteepAdvice` to be updated.
  id: ID!

  # An object where the defined keys will be set on the `SteepAdvice` identified by our globally unique `ID`.
  steepAdvicePatch: SteepAdvicePatch!
}

# The output of our `updateSteepAdvice` mutation.
type UpdateSteepAdvicePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  steepAdvice: SteepAdvice

  # Reads a single `Tea` that is related to this `SteepAdvice`.
  teaByTeaUuid: Tea

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateTeaByNameAndBrandUuid` mutation.
input UpdateTeaByNameAndBrandUuidInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The name of the tea
  name: String!

  # The unique identifier of the brand of the tea
  brandUuid: Uuid!

  # An object where the defined keys will be set on the `Tea` identified by our unique key.
  teaPatch: TeaPatch!
}

# All input for the `updateTeaByUuid` mutation.
input UpdateTeaByUuidInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The unique identifier of the tea
  uuid: Uuid!

  # An object where the defined keys will be set on the `Tea` identified by our unique key.
  teaPatch: TeaPatch!
}

# All input for the `updateTea` mutation.
input UpdateTeaInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Tea` to be updated.
  id: ID!

  # An object where the defined keys will be set on the `Tea` identified by our globally unique `ID`.
  teaPatch: TeaPatch!
}

# The output of our `updateTea` mutation.
type UpdateTeaPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  tea: Tea

  # Reads a single `Brand` that is related to this `Tea`.
  brandByBrandUuid: Brand

  # Reads a single `Category` that is related to this `Tea`.
  categoryByCategoryUuid: Category

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateUpdatedAt` mutation.
input UpdateUpdatedAtInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
}

# The output of our `updateUpdatedAt` mutation.
type UpdateUpdatedAtPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  string: String

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122).
scalar Uuid
